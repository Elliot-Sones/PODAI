-- =============================================================
-- Podverse Database Setup
-- Run this in Supabase Dashboard > SQL Editor
-- =============================================================

-- Step 1: Enable required extensions
CREATE EXTENSION IF NOT EXISTS vector WITH SCHEMA extensions;
CREATE EXTENSION IF NOT EXISTS pgroonga;

-- Make vector available in public schema
CREATE EXTENSION IF NOT EXISTS vector WITH SCHEMA public;

-- Step 2: Core functions
CREATE OR REPLACE FUNCTION "public"."requesting_user_id"() RETURNS "text"
    LANGUAGE "sql" STABLE
    AS $$
  select nullif(current_setting('request.jwt.claims', true)::json->>'sub', '')::text;
$$;

CREATE OR REPLACE FUNCTION "public"."episode_state"("status" "jsonb") RETURNS "text"
    LANGUAGE "plpgsql" STABLE
    AS $$
DECLARE
    started_at TIMESTAMP;
    completed_at TIMESTAMP;
    message TEXT;
BEGIN
    started_at := (status ->> 'startedAt')::TIMESTAMP;
    completed_at := (status ->> 'completedAt')::TIMESTAMP;
    message := status ->> 'message';

    IF started_at IS NULL THEN
        RETURN 'pending';
    ELSIF started_at IS NOT NULL AND completed_at IS NOT NULL AND message IS NOT NULL AND message LIKE 'Error%' THEN
        RETURN 'error';
    ELSIF started_at IS NOT NULL AND completed_at IS NULL THEN
        RETURN 'processing';
    ELSE
        RETURN 'ready';
    END IF;
END;
$$;

CREATE OR REPLACE FUNCTION "public"."is_podcast_owner"("episodeid" bigint, "userid" "text") RETURNS boolean
    LANGUAGE "plpgsql"
    AS $$
#variable_conflict use_variable
begin
  return (
  select EXISTS (
    SELECT 1
    FROM "Episodes" e
    JOIN "Podcasts" p ON p.id = e.podcast
    WHERE e.id = "episodeid"
    AND p.owner = "userid"
  ) );
end;
$$;

CREATE OR REPLACE FUNCTION "public"."is_podcast_owner_with_podcast_id"("podcastId" bigint, "userid" "text") RETURNS boolean
    LANGUAGE "plpgsql"
    AS $$
#variable_conflict use_variable
begin return (
    select EXISTS (
        SELECT 1
        FROM "Podcasts" p
        WHERE p.id = "podcastId" AND p.owner = "userid"
    )
);
end;
$$;

-- Step 3: Core tables
CREATE TABLE IF NOT EXISTS "public"."Users" (
    "id" "text" DEFAULT "public"."requesting_user_id"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "displayName" "text",
    CONSTRAINT "Users_pkey" PRIMARY KEY ("id")
);

CREATE TABLE IF NOT EXISTS "public"."Podcasts" (
    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "slug" "text" NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "url" "text",
    "rssUrl" "text",
    "imageUrl" "text",
    "owner" "text" DEFAULT "public"."requesting_user_id"(),
    "copyright" "text",
    "author" "text",
    "private" boolean DEFAULT true,
    "uuid" "uuid" DEFAULT "gen_random_uuid"(),
    "published" boolean DEFAULT false,
    "process" boolean DEFAULT false NOT NULL,
    CONSTRAINT "Podcasts_pkey" PRIMARY KEY ("id"),
    CONSTRAINT "Podcasts_unique_id_and_slug" UNIQUE ("id", "slug")
);

CREATE TABLE IF NOT EXISTS "public"."Episodes" (
    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "podcast" bigint NOT NULL,
    "slug" "text" NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "url" "text",
    "imageUrl" "text",
    "audioUrl" "text",
    "transcriptUrl" "text",
    "summaryUrl" "text",
    "pubDate" timestamp with time zone,
    "guid" "text",
    "error" "jsonb",
    "rawTranscriptUrl" "text",
    "modified_at" timestamp with time zone DEFAULT "now"(),
    "status" "jsonb",
    "originalAudioUrl" "text",
    "published" boolean DEFAULT false,
    "duration" bigint,
    CONSTRAINT "Episodes_pkey" PRIMARY KEY ("id"),
    CONSTRAINT "Episodes_unique_guid" UNIQUE ("guid"),
    CONSTRAINT "Episodes_unique_id_and_guid" UNIQUE ("id", "guid")
);

CREATE TABLE IF NOT EXISTS "public"."Documents" (
    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    "checksum" "text",
    "meta" "jsonb",
    "episode" bigint,
    "source" "text",
    "created_at" timestamp with time zone,
    CONSTRAINT "nods_page_pkey" PRIMARY KEY ("id"),
    CONSTRAINT "uniquedocumentsourceurl" UNIQUE ("episode", "source")
);

CREATE TABLE IF NOT EXISTS "public"."Chunks" (
    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    "document" bigint NOT NULL,
    "content" "text",
    "embedding" "public"."vector"(768),
    "meta" "jsonb",
    CONSTRAINT "nods_page_section_pkey" PRIMARY KEY ("id")
);

CREATE TABLE IF NOT EXISTS "public"."SpeakerMap" (
    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "speakerId" "text" NOT NULL,
    "name" "text",
    "episode" bigint NOT NULL,
    "modified_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "SpeakerMap_pkey" PRIMARY KEY ("id"),
    CONSTRAINT "uniquespeakermapping" UNIQUE ("speakerId", "episode")
);

CREATE TABLE IF NOT EXISTS "public"."Subscriptions" (
    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "user" "text" NOT NULL,
    "description" "text",
    "state" "text" NOT NULL,
    "plan" "text" NOT NULL,
    "billingProviderId" "text",
    "modified_at" timestamp with time zone DEFAULT "now"(),
    "start_time" timestamp with time zone,
    "end_time" timestamp with time zone,
    CONSTRAINT "Subscriptions_pkey" PRIMARY KEY ("id")
);

CREATE TABLE IF NOT EXISTS "public"."Suggestions" (
    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    "episode" bigint,
    "suggestion" "text",
    "podcast" bigint,
    CONSTRAINT "Suggestions_pkey" PRIMARY KEY ("id")
);

CREATE TABLE IF NOT EXISTS "public"."Invitations" (
    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "modified_at" timestamp with time zone DEFAULT "now"(),
    "podcast" bigint NOT NULL,
    "name" "text",
    "email" "text" NOT NULL,
    "status" "text",
    CONSTRAINT "Invitations_pkey" PRIMARY KEY ("id")
);

-- Step 4: Foreign keys
ALTER TABLE ONLY "public"."Episodes"
    ADD CONSTRAINT "Episodes_podcast_fkey" FOREIGN KEY ("podcast") REFERENCES "public"."Podcasts"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "public"."Documents"
    ADD CONSTRAINT "public_Documents_episode_fkey" FOREIGN KEY ("episode") REFERENCES "public"."Episodes"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "public"."Chunks"
    ADD CONSTRAINT "public_Chunks_document_fkey" FOREIGN KEY ("document") REFERENCES "public"."Documents"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "public"."SpeakerMap"
    ADD CONSTRAINT "SpeakerMap_episode_fkey" FOREIGN KEY ("episode") REFERENCES "public"."Episodes"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "public"."Invitations"
    ADD CONSTRAINT "Invitations_podcast_fkey" FOREIGN KEY ("podcast") REFERENCES "public"."Podcasts"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "public"."Podcasts"
    ADD CONSTRAINT "public_Podcasts_owner_fkey" FOREIGN KEY ("owner") REFERENCES "public"."Users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."Subscriptions"
    ADD CONSTRAINT "public_Subscriptions_user_fkey" FOREIGN KEY ("user") REFERENCES "public"."Users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "public"."Suggestions"
    ADD CONSTRAINT "Suggestions_podcast_fkey" FOREIGN KEY ("podcast") REFERENCES "public"."Podcasts"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "public"."Suggestions"
    ADD CONSTRAINT "public_Suggestions_episode_fkey" FOREIGN KEY ("episode") REFERENCES "public"."Episodes"("id") ON UPDATE CASCADE ON DELETE CASCADE;

-- Step 5: Indexes
CREATE INDEX IF NOT EXISTS "Chunks_document_idx" ON "public"."Chunks" USING "hash" ("document");
CREATE INDEX IF NOT EXISTS "Documents_episode_idx" ON "public"."Documents" USING "hash" ("episode");
CREATE INDEX IF NOT EXISTS "Podcasts_owner_idx" ON "public"."Podcasts" USING "hash" ("owner");
CREATE INDEX IF NOT EXISTS "SpeakerMap_episode_idx" ON "public"."SpeakerMap" USING "hash" ("episode");
CREATE INDEX IF NOT EXISTS "Suggestions_episode_idx" ON "public"."Suggestions" USING "hash" ("episode");

-- Step 6: View
CREATE OR REPLACE VIEW "public"."Episodes_with_state" WITH ("security_invoker"='on') AS
 SELECT "Episodes"."id",
    "Episodes"."created_at",
    "Episodes"."podcast",
    "Episodes"."slug",
    "Episodes"."title",
    "Episodes"."description",
    "Episodes"."url",
    "Episodes"."imageUrl",
    "Episodes"."audioUrl",
    "Episodes"."transcriptUrl",
    "Episodes"."summaryUrl",
    "Episodes"."pubDate",
    "Episodes"."guid",
    "Episodes"."error",
    "Episodes"."rawTranscriptUrl",
    "Episodes"."modified_at",
    "Episodes"."status",
    "Episodes"."originalAudioUrl",
    "Episodes"."published",
    "Episodes"."duration",
    "public"."episode_state"("Episodes"."status") AS "state"
   FROM "public"."Episodes";

-- Step 7: RPC functions
CREATE OR REPLACE FUNCTION "public"."all_podcasts"("limit" integer, "isPrivate" boolean, "isPublished" boolean) RETURNS TABLE("id" bigint, "title" "text", "description" "text", "slug" "text", "private" boolean, "published" boolean, "imageUrl" "text", "newestEpisode" timestamp with time zone)
    LANGUAGE "plpgsql"
    AS $$#variable_conflict use_variable
begin
  return query
select p.id, p.title, p.description, p.slug, p.private, p.published, p."imageUrl", e."pubDate" as "newestEpisode"
from
  "Podcasts" p
JOIN (
  select DISTINCT ON (podcast)
    id, podcast, "pubDate"
  FROM "Episodes"
  ORDER BY podcast, "pubDate" DESC
) e
ON e.podcast = p.id
WHERE p.private = "isPrivate"
order by "newestEpisode" DESC
LIMIT "limit";
end;$$;

CREATE OR REPLACE FUNCTION "public"."chunk_vector_search"("embedding" "public"."vector", "match_threshold" double precision, "match_count" integer, "min_content_length" integer) RETURNS TABLE("id" bigint, "document" bigint, "meta" "jsonb", "content" "text", "similarity" double precision)
    LANGUAGE "plpgsql"
    AS $$
#variable_conflict use_variable
begin
  return query
  select
    c.id, c.document, c.meta, c.content,
    (c.embedding <#> embedding) * -1 as similarity
  from "Chunks" c
  JOIN "Documents" d ON d.id = c.document
  JOIN "Episodes" e on e.id = d.episode
  JOIN "Podcasts" p ON p.id = e.podcast
  where length(c.content) >= min_content_length
  and (c.embedding <#> embedding) * -1 > match_threshold
  AND (p.private = FALSE AND p.published = TRUE)
  order by c.embedding <#> embedding
  limit match_count;
end;
$$;

CREATE OR REPLACE FUNCTION "public"."chunk_vector_search_episode"("embedding" "public"."vector", "match_threshold" double precision, "match_count" integer, "min_content_length" integer, "episode_id" bigint) RETURNS TABLE("id" bigint, "document" bigint, "meta" "jsonb", "content" "text", "similarity" double precision)
    LANGUAGE "plpgsql"
    AS $$
#variable_conflict use_variable
begin
  return query
  select
    c.id, c.document, c.meta, c.content,
    (c.embedding <#> embedding) * -1 as similarity
  from "Chunks" c
  JOIN "Documents" d ON d.id = c.document
  JOIN "Episodes" e on e.id = d.episode AND e.id = episode_id
  where length(c.content) >= min_content_length
  and (c.embedding <#> embedding) * -1 > match_threshold
  order by c.embedding <#> embedding
  limit match_count;
end;
$$;

CREATE OR REPLACE FUNCTION "public"."chunk_vector_search_podcast"("embedding" "public"."vector", "match_threshold" double precision, "match_count" integer, "min_content_length" integer, "podcast_id" bigint) RETURNS TABLE("id" bigint, "document" bigint, "meta" "jsonb", "content" "text", "similarity" double precision)
    LANGUAGE "plpgsql"
    AS $$
#variable_conflict use_variable
begin
  return query
  select
    c.id, c.document, c.meta, c.content,
    (c.embedding <#> embedding) * -1 as similarity
  from "Chunks" c
  JOIN "Documents" d ON d.id = c.document
  JOIN "Episodes" e on e.id = d.episode
  JOIN "Podcasts" p ON p.id = e.podcast AND p.id = podcast_id
  where length(c.content) >= min_content_length
  and (c.embedding <#> embedding) * -1 > match_threshold
  order by c.embedding <#> embedding
  limit match_count;
end;
$$;

CREATE OR REPLACE FUNCTION "public"."latest_episodes"("limit" integer) RETURNS TABLE("id" bigint, "title" "text", "description" "text", "slug" "text", "imageUrl" "text", "pubDate" timestamp with time zone, "podcastSlug" "text", "podcastTitle" "text", "podcastImageUrl" "text")
    LANGUAGE "plpgsql"
    AS $$#variable_conflict use_variable
begin
  return query
select * from (
select distinct
  on ("Episodes".podcast)
  "Episodes".id as id,
  "Episodes".title as title,
  "Episodes".description as description,
  "Episodes".slug as slug,
  "Episodes"."imageUrl" as "imageUrl",
  "Episodes"."pubDate" as "pubDate",
  "Podcasts"."slug" as "podcastSlug",
  "Podcasts"."title" as "podcastTitle",
  "Podcasts"."imageUrl" AS "podcastImageUrl"
from
  "Episodes"
INNER JOIN "Podcasts" ON "Podcasts".id = "Episodes".podcast
where
"Episodes"."status" IS NOT NULL
AND ("Podcasts".private = false)
AND ("Podcasts".published = true)
AND ("Episodes"."status" ->> 'startedAt') <> 'null'
AND ("Episodes"."status" ->> 'completedAt') <> 'null'
AND "Episodes"."status" ->> 'message' NOT LIKE 'Error%'
  ORDER BY "Episodes".podcast, "Episodes"."pubDate" DESC
) as e
ORDER BY "pubDate" DESC
LIMIT "limit";
end;$$;

CREATE OR REPLACE FUNCTION "public"."podcast_search"("query" "text", "match_count" integer) RETURNS TABLE("id" bigint, "title" "text", "description" "text", "slug" "text", "imageUrl" "text")
    LANGUAGE "plpgsql"
    AS $$#variable_conflict use_variable
begin
  return query
  select
    "Podcasts".id,
    "Podcasts".title,
    "Podcasts".description,
    "Podcasts".slug,
    "Podcasts"."imageUrl"
  from "Podcasts"
  where ("Podcasts".private = FALSE AND "Podcasts".published = TRUE) AND (("Podcasts".title &@~ query) OR ("Podcasts".description &@~ query))
  limit match_count;
end;$$;

CREATE OR REPLACE FUNCTION "public"."episode_search"("query" "text", "podcast_slug" "text", "match_count" integer) RETURNS TABLE("id" bigint, "title" "text", "description" "text", "slug" "text", "podcast" bigint, "imageUrl" "text")
    LANGUAGE "plpgsql"
    AS $$
#variable_conflict use_variable
begin
  return query
  select q.id, q.title, q.description, q.slug, q.podcast, q."imageUrl" FROM (
  select
    e.id as id,
    e.title as title,
    e.description as description,
    e.slug as slug,
    e.podcast as podcast,
    e."imageUrl" as "imageUrl",
    p.id as podcast_id,
    p.private,
    p.published
  from "Episodes" e
  JOIN (select * from "Podcasts") p ON p.id = e.podcast
WHERE (episode_state(e.status) = 'ready')
      AND ((e.title &@~ query) OR (e.description &@~ query))
      AND (podcast_slug IS NULL OR p.slug = podcast_slug)
  order by e."pubDate" DESC
  limit match_count
  ) q;
end;
$$;

-- Step 8: Row Level Security
ALTER TABLE "public"."Users" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."Podcasts" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."Episodes" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."Documents" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."Chunks" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."SpeakerMap" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."Subscriptions" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."Suggestions" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."Invitations" ENABLE ROW LEVEL SECURITY;

-- RLS Policies: Read access
CREATE POLICY "Allow read access for all users" ON "public"."Podcasts" FOR SELECT USING (true);
CREATE POLICY "Allow read access for all users" ON "public"."Episodes" FOR SELECT USING (true);
CREATE POLICY "Allow read access for all users" ON "public"."Documents" FOR SELECT USING (true);
CREATE POLICY "Allow read access for all users" ON "public"."Chunks" FOR SELECT USING (true);
CREATE POLICY "Allow read access for all users" ON "public"."SpeakerMap" FOR SELECT USING (true);
CREATE POLICY "Allow read access for all users" ON "public"."Suggestions" FOR SELECT USING (true);
CREATE POLICY "Enable read access for all users" ON "public"."Users" FOR SELECT USING (true);
CREATE POLICY "Enable read access for all users" ON "public"."Invitations" FOR SELECT USING (true);

-- RLS Policies: Insert
CREATE POLICY "Allow insert by any authed user" ON "public"."Podcasts" FOR INSERT WITH CHECK (("public"."requesting_user_id"() <> ''::"text"));
CREATE POLICY "Allow insert on Users when requesting_user_id() is not empty" ON "public"."Users" FOR INSERT WITH CHECK (("public"."requesting_user_id"() <> ''::"text"));
CREATE POLICY "Allow insert by any authed user" ON "public"."Subscriptions" FOR INSERT WITH CHECK (("public"."requesting_user_id"() <> ''::"text"));
CREATE POLICY "Enable insert for authenticated users only" ON "public"."Invitations" FOR INSERT TO "authenticated" WITH CHECK (true);

CREATE POLICY "Allow insert by Podcast owner" ON "public"."Episodes" FOR INSERT WITH CHECK ("public"."is_podcast_owner_with_podcast_id"("podcast", "public"."requesting_user_id"()));
CREATE POLICY "Allow insert by Podcast owner" ON "public"."Documents" FOR INSERT WITH CHECK ("public"."is_podcast_owner"("episode", "public"."requesting_user_id"()));
CREATE POLICY "Allow insert by Podcast owner" ON "public"."Chunks" FOR INSERT WITH CHECK ("public"."is_podcast_owner"(( SELECT "d"."episode" FROM "public"."Documents" "d" WHERE ("d"."id" = "Chunks"."document")), "public"."requesting_user_id"()));
CREATE POLICY "Allow insert by Podcast owner" ON "public"."SpeakerMap" FOR INSERT WITH CHECK ("public"."is_podcast_owner"("episode", "public"."requesting_user_id"()));
CREATE POLICY "Allow insert by Podcast owner" ON "public"."Suggestions" FOR INSERT WITH CHECK ("public"."is_podcast_owner"("episode", "public"."requesting_user_id"()));

-- RLS Policies: Update
CREATE POLICY "Allow update by Podcast owner" ON "public"."Podcasts" FOR UPDATE USING (("public"."requesting_user_id"() = "owner"));
CREATE POLICY "Allow update by Podcast owner" ON "public"."Episodes" FOR UPDATE USING ("public"."is_podcast_owner_with_podcast_id"("podcast", "public"."requesting_user_id"()));
CREATE POLICY "Allow update by Podcast owner" ON "public"."Documents" FOR UPDATE USING ("public"."is_podcast_owner"("episode", "public"."requesting_user_id"()));
CREATE POLICY "Allow update by Podcast owner" ON "public"."SpeakerMap" FOR UPDATE USING ("public"."is_podcast_owner"("episode", "public"."requesting_user_id"()));
CREATE POLICY "Allow update by Podcast owner" ON "public"."Suggestions" FOR UPDATE USING ("public"."is_podcast_owner"("episode", "public"."requesting_user_id"()));
CREATE POLICY "Allow user update if id matches requesting_user_id()" ON "public"."Users" FOR UPDATE USING (("id" = "public"."requesting_user_id"()));

-- RLS Policies: Delete
CREATE POLICY "Allow delete by Podcast owner" ON "public"."Podcasts" FOR DELETE USING (("public"."requesting_user_id"() = "owner"));
CREATE POLICY "Allow delete by Podcast owner" ON "public"."Episodes" FOR DELETE USING ("public"."is_podcast_owner_with_podcast_id"("podcast", "public"."requesting_user_id"()));
CREATE POLICY "Allow delete by Podcast owner" ON "public"."Documents" FOR DELETE USING ("public"."is_podcast_owner"("episode", "public"."requesting_user_id"()));
CREATE POLICY "Allow delete by Podcast owner" ON "public"."Chunks" FOR DELETE USING ("public"."is_podcast_owner"(( SELECT "d"."episode" FROM "public"."Documents" "d" WHERE ("d"."id" = "Chunks"."document")), "public"."requesting_user_id"()));
CREATE POLICY "Allow delete by Podcast owner" ON "public"."SpeakerMap" FOR DELETE USING ("public"."is_podcast_owner"("episode", "public"."requesting_user_id"()));
CREATE POLICY "Allow delete by Podcast owner" ON "public"."Suggestions" FOR DELETE USING ("public"."is_podcast_owner"("episode", "public"."requesting_user_id"()));
CREATE POLICY "Allow access by owner" ON "public"."Subscriptions" USING (("public"."requesting_user_id"() = "user"));

-- Step 9: Grant permissions
GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";

GRANT ALL ON ALL TABLES IN SCHEMA "public" TO "anon";
GRANT ALL ON ALL TABLES IN SCHEMA "public" TO "authenticated";
GRANT ALL ON ALL TABLES IN SCHEMA "public" TO "service_role";
GRANT ALL ON ALL SEQUENCES IN SCHEMA "public" TO "anon";
GRANT ALL ON ALL SEQUENCES IN SCHEMA "public" TO "authenticated";
GRANT ALL ON ALL SEQUENCES IN SCHEMA "public" TO "service_role";
GRANT ALL ON ALL FUNCTIONS IN SCHEMA "public" TO "anon";
GRANT ALL ON ALL FUNCTIONS IN SCHEMA "public" TO "authenticated";
GRANT ALL ON ALL FUNCTIONS IN SCHEMA "public" TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres", "anon", "authenticated", "service_role";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres", "anon", "authenticated", "service_role";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres", "anon", "authenticated", "service_role";

-- =============================================================
-- Step 10: Categories (Podverse custom)
-- =============================================================
CREATE TABLE IF NOT EXISTS "Categories" (
  id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  name text NOT NULL,
  slug text NOT NULL UNIQUE,
  description text,
  "imageUrl" text,
  "displayOrder" integer DEFAULT 0
);

CREATE TABLE IF NOT EXISTS "PodcastCategories" (
  id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  podcast bigint REFERENCES "Podcasts"(id) ON DELETE CASCADE,
  category bigint REFERENCES "Categories"(id) ON DELETE CASCADE,
  UNIQUE (podcast, category)
);

ALTER TABLE "Categories" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "PodcastCategories" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Categories are viewable by everyone" ON "Categories" FOR SELECT USING (true);
CREATE POLICY "PodcastCategories are viewable by everyone" ON "PodcastCategories" FOR SELECT USING (true);
CREATE POLICY "Service role can manage categories" ON "Categories" FOR ALL USING (true);
CREATE POLICY "Service role can manage podcast categories" ON "PodcastCategories" FOR ALL USING (true);

-- Grant access
GRANT ALL ON TABLE "public"."Categories" TO "anon", "authenticated", "service_role";
GRANT ALL ON TABLE "public"."PodcastCategories" TO "anon", "authenticated", "service_role";

-- Seed categories
INSERT INTO "Categories" (name, slug, description, "displayOrder") VALUES
  ('Technology', 'technology', 'Podcasts about tech, AI, software, and the digital world', 1),
  ('Health', 'health', 'Podcasts about health, wellness, fitness, and mental well-being', 2),
  ('Business', 'business', 'Podcasts about business, startups, investing, and entrepreneurship', 3)
ON CONFLICT (slug) DO NOTHING;

-- =============================================================
-- Step 11: Topics (Podverse custom)
-- =============================================================
CREATE TABLE IF NOT EXISTS "Topics" (
  id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  name text NOT NULL,
  slug text NOT NULL UNIQUE,
  description text,
  embedding vector(768),
  created_at timestamptz DEFAULT now()
);

CREATE TABLE IF NOT EXISTS "EpisodeTopics" (
  id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  episode bigint REFERENCES "Episodes"(id) ON DELETE CASCADE,
  topic bigint REFERENCES "Topics"(id) ON DELETE CASCADE,
  confidence double precision DEFAULT 1.0,
  UNIQUE (episode, topic)
);

ALTER TABLE "Topics" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "EpisodeTopics" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Topics are viewable by everyone" ON "Topics" FOR SELECT USING (true);
CREATE POLICY "EpisodeTopics are viewable by everyone" ON "EpisodeTopics" FOR SELECT USING (true);
CREATE POLICY "Service role can manage topics" ON "Topics" FOR ALL USING (true);
CREATE POLICY "Service role can manage episode topics" ON "EpisodeTopics" FOR ALL USING (true);

-- Grant access
GRANT ALL ON TABLE "public"."Topics" TO "anon", "authenticated", "service_role";
GRANT ALL ON TABLE "public"."EpisodeTopics" TO "anon", "authenticated", "service_role";

-- Topic vector search
CREATE OR REPLACE FUNCTION topic_vector_search(
  query_embedding vector(768),
  similarity_threshold float DEFAULT 0.7,
  match_count int DEFAULT 20
)
RETURNS TABLE(
  id bigint,
  name text,
  slug text,
  description text,
  similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    t.id, t.name, t.slug, t.description,
    1 - (t.embedding <=> query_embedding) as similarity
  FROM "Topics" t
  WHERE t.embedding IS NOT NULL
    AND 1 - (t.embedding <=> query_embedding) > similarity_threshold
  ORDER BY t.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

-- Episodes by topic
CREATE OR REPLACE FUNCTION episodes_by_topic(
  topic_slug text,
  match_count int DEFAULT 50
)
RETURNS TABLE(
  episode_id bigint,
  episode_title text,
  episode_slug text,
  podcast_id bigint,
  podcast_title text,
  podcast_slug text,
  podcast_image text,
  confidence double precision
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    e.id as episode_id,
    e.title as episode_title,
    e.slug as episode_slug,
    p.id as podcast_id,
    p.title as podcast_title,
    p.slug as podcast_slug,
    p."imageUrl" as podcast_image,
    et.confidence
  FROM "EpisodeTopics" et
  JOIN "Episodes" e ON e.id = et.episode
  JOIN "Podcasts" p ON p.id = e.podcast
  JOIN "Topics" t ON t.id = et.topic
  WHERE t.slug = topic_slug
  ORDER BY et.confidence DESC, e."pubDate" DESC
  LIMIT match_count;
END;
$$;

-- =============================================================
-- Done! All tables, functions, and policies created.
-- =============================================================
