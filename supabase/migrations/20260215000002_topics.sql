-- Topics for cross-podcast discovery
CREATE TABLE IF NOT EXISTS "Topics" (
  id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  name text NOT NULL,
  slug text NOT NULL UNIQUE,
  description text,
  embedding vector(768),
  created_at timestamptz DEFAULT now()
);

-- Episode-topic relationships
CREATE TABLE IF NOT EXISTS "EpisodeTopics" (
  id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  episode bigint REFERENCES "Episodes"(id) ON DELETE CASCADE,
  topic bigint REFERENCES "Topics"(id) ON DELETE CASCADE,
  confidence double precision DEFAULT 1.0,
  UNIQUE (episode, topic)
);

-- Enable RLS
ALTER TABLE "Topics" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "EpisodeTopics" ENABLE ROW LEVEL SECURITY;

-- Read access for all users
CREATE POLICY "Topics are viewable by everyone" ON "Topics"
  FOR SELECT USING (true);

CREATE POLICY "EpisodeTopics are viewable by everyone" ON "EpisodeTopics"
  FOR SELECT USING (true);

-- Insert/update for authenticated and service roles
CREATE POLICY "Service role can manage topics" ON "Topics"
  FOR ALL USING (true);

CREATE POLICY "Service role can manage episode topics" ON "EpisodeTopics"
  FOR ALL USING (true);

-- Index on topic embeddings for vector search
CREATE INDEX IF NOT EXISTS topics_embedding_idx ON "Topics"
  USING ivfflat (embedding vector_cosine_ops)
  WITH (lists = 100);

-- Stored procedure: semantic topic search
CREATE OR REPLACE FUNCTION topic_vector_search(
  query_embedding vector(768),
  similarity_threshold float DEFAULT 0.7,
  match_count int DEFAULT 20
)
RETURNS TABLE(
  id bigint,
  name text,
  slug text,
  description text,
  similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    t.id,
    t.name,
    t.slug,
    t.description,
    1 - (t.embedding <=> query_embedding) as similarity
  FROM "Topics" t
  WHERE t.embedding IS NOT NULL
    AND 1 - (t.embedding <=> query_embedding) > similarity_threshold
  ORDER BY t.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

-- Stored procedure: find episodes by topic across all podcasts
CREATE OR REPLACE FUNCTION episodes_by_topic(
  topic_slug text,
  match_count int DEFAULT 50
)
RETURNS TABLE(
  episode_id bigint,
  episode_title text,
  episode_slug text,
  podcast_id bigint,
  podcast_title text,
  podcast_slug text,
  podcast_image text,
  confidence double precision
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    e.id as episode_id,
    e.title as episode_title,
    e.slug as episode_slug,
    p.id as podcast_id,
    p.title as podcast_title,
    p.slug as podcast_slug,
    p."imageUrl" as podcast_image,
    et.confidence
  FROM "EpisodeTopics" et
  JOIN "Episodes" e ON e.id = et.episode
  JOIN "Podcasts" p ON p.id = e.podcast
  JOIN "Topics" t ON t.id = et.topic
  WHERE t.slug = topic_slug
  ORDER BY et.confidence DESC, e."pubDate" DESC
  LIMIT match_count;
END;
$$;
